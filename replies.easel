pub gallery chat.ChatReplyPanel
pub gallery chat.ChatReplyHintPanel

prop chat.ChatReply

prop chat.ChatReplyHint
prop chat.ChatReplyEnergyCost = 1
symbol ChatReplyHint:AlternativesAvailable
symbol ChatReplyHint:KeepHolding
symbol ChatReplyHint:CyclingAvailable
symbol ChatReplyHint:NotEnoughEnergy

pub fn chat.ChatReplyControls {
    give ChatReplyPanel {
        InsetPanel(padding=0) {
            HStack(hPadding=0.5, vPadding=0.5, vAlign=VAlign:Middle) {
                with ChatReplyHint {
                    Link(
                        HoldIntent<changeReply>,
                        bold=false, expand=true, padding=0.5, align=Align:Left,
                        color = ChatReplyHint ? undefined : #fff) {
                        P {
                            with ChatReply {
                                let revealLength = 1
                                with Tick(0.02s) {
                                    %(ChatReply.Substring(0, revealLength))
                                    if revealLength < ChatReply.Length {
                                        revealLength += 1
                                    } else {
                                        break
                                    }
                                }
                            }
                        }
                    }
                }
            
                with ChatReply {
                    if ChatReply {
                        RaisedButton(PressIntent<acceptReply>, backgroundColor=Color:Primary) { "Send" }
                    } else {
                        RaisedButton(backgroundColor=Color:Primary, opacity=0.5) { "Send" }
                    }
                }
            }
        }
    }

    give ChatReplyHintPanel {
        VStack(minHeight=1.5) {
            P(fontSize=0.9, align=Align:Center, color=#fffa) {
                with ChatReplyHint, ChatReplyEnergyCost {
                    if ChatReplyHint == ChatReplyHint:AlternativesAvailable {
                        "You can "
                        Span(bold=true) { "click and hold" }
                        " your reply to think of something else to say ("
                        Span(bold=true, color=Color:Energy) {
                            "-" + ChatReplyEnergyCost + " Energy "
                            Icon("fa-solid fa-bolt")
                        }
                        ")"
                    } else if ChatReplyHint == ChatReplyHint:KeepHolding {
                        Span(bold=true) { "Keep holding" }
                        "... thinking of something else to say"
                    } else if ChatReplyHint == ChatReplyHint:NotEnoughEnergy {
                        Span(bold=true, color=Color:Negative) { "Not enough energy" }
                    } else if ChatReplyHint == ChatReplyHint:CyclingAvailable {
                        Span(bold=true) { "Click" }
                        " your reply to cycle between options"
                    }
                }
            }
        }
    }
}

pub await fn chat.ChooseReply(options, rethinkDuration=1s, energyCost=7, [owner]) -> replyText {
    let replyText = null
    await Subspawn reply {
        on Pressed<acceptReply> {
            replyText = ChatReply
            SendChat(text=replyText)
            ChatReply = null
            ChatReplyHint = null
            Despawn
        }

        
        let selectedReplyIndex = 0
        let numOptionsRevealed = 1
        loop {
            ChatReply = options[selectedReplyIndex]
            if options.Length <= 1 { break }
            
            let canRevealMoreOptions = numOptionsRevealed < options.Length
            let hasEnoughEnergyForReveal = EnergyRemaining >= energyCost
            ChatReplyHint = canRevealMoreOptions ? ChatReplyHint:AlternativesAvailable : ChatReplyHint:CyclingAvailable
            ChatReplyEnergyCost = energyCost
            
            await Pressed<changeReply>
            let thinkingStart = Tick
            
            ChatReply = ""
            if canRevealMoreOptions {
                ChatReplyHint = hasEnoughEnergyForReveal ? ChatReplyHint:KeepHolding : ChatReplyHint:NotEnoughEnergy
                behavior<energySparks> on Paint(hasEnoughEnergyForReveal ? 1 : 0.1s) {
                    Spark(
                        color = hasEnoughEnergyForReveal ? Color:Energy : Color:Negative,
                        flicker=0.5,
                        body=@((Random < 0.5 ? -1 : 1)*(40+20*Random), 50*SignedRandom),
                        radius=1,
                        velocity=-0.5 * body,
                        luminous=1, bloom=5, bloomAlpha=1, glare=1,
                        dissipate=1s,
                    )
                }
            }
            
            await Unpressed<changeReply>, Tick(rethinkDuration)
            delete behavior<energySparks>
            
            let thinkingDuration = Tick - thinkingStart

            if thinkingDuration >= rethinkDuration && numOptionsRevealed < options.Length {
                if hasEnoughEnergyForReveal {
                    numOptionsRevealed += 1
                    selectedReplyIndex = numOptionsRevealed - 1
                    ConsumeEnergy(energyCost)
                }
            } else {
                selectedReplyIndex = (selectedReplyIndex + 1) % numOptionsRevealed
            }
        }
    }
    return replyText
}