pub gallery chat.ChatReplyContent
pub gallery chat.ChatReplyButton
pub gallery chat.ChatReplyHint

gallery reply.ChatReplyText

pub await fn chat.ChooseReply(options, rethinkDuration=1s, energyCost=7, [owner]) -> replyText {
    let replyText = null
    await Subspawn reply {
        let selectedReplyIndex = 0
        let numOptionsRevealed = 1
        loop {
            replyText = options[selectedReplyIndex]
            DisplayChatReplyControls(replyText=, hasAlternatives = options.Length > 1)
            
            if options.Length <= 1 { break }
            
            let canRevealMoreOptions = numOptionsRevealed < options.Length
            let hasEnoughEnergyForReveal = EnergyRemaining >= energyCost

            if canRevealMoreOptions {
                give<hint> ChatReplyHint {
                    "You can "
                    Span(bold=true) { "click and hold" }
                    " your reply to think of something else to say ("
                    Span(bold=true, color=Color:Energy) {
                        "-" + energyCost + " Energy "
                        Icon("fa-solid fa-bolt")
                    }
                    ")"
                }
            } else {
                give<hint> ChatReplyHint {
                    Span(bold=true) { "Click" }
                    " your reply to cycle between options"
                }
            }
            
            await Pressed<changeReply>
            let thinkingStart = Tick
            
            if canRevealMoreOptions {
                if hasEnoughEnergyForReveal {
                    give<hint> ChatReplyHint {
                        Span(bold=true) { "Keep holding" }
                        "... thinking of something else to say"
                    }
                } else {
                    give<hint> ChatReplyHint {
                        Span(bold=true, color=Color:Negative) { "Not enough energy" }
                    }
                }
                behavior<energySparks> on Paint(hasEnoughEnergyForReveal ? 1 : 0.1s) {
                    Spark(
                        color = hasEnoughEnergyForReveal ? Color:Energy : Color:Negative,
                        flicker=0.5,
                        body=@((Random < 0.5 ? -1 : 1)*(40+20*Random), 50*SignedRandom),
                        radius=1,
                        velocity=-0.5 * body,
                        luminous=1, bloom=5, bloomAlpha=1, glare=1,
                        dissipate=1s,
                    )
                }
            }
            
            await Unpressed<changeReply>, Tick(rethinkDuration)
            delete behavior<energySparks>
            
            let thinkingDuration = Tick - thinkingStart

            if thinkingDuration >= rethinkDuration && numOptionsRevealed < options.Length {
                if hasEnoughEnergyForReveal {
                    numOptionsRevealed += 1
                    selectedReplyIndex = numOptionsRevealed - 1
                    ConsumeEnergy(energyCost)
                }
            } else {
                selectedReplyIndex = (selectedReplyIndex + 1) % numOptionsRevealed
            }
        }
    }
    return replyText
}

fn reply.DisplayChatReplyControls(replyText, hasAlternatives, [chat]) {
    give ChatReplyContent {
        if hasAlternatives {
            Link(
                HoldIntent<changeReply>,
                bold=false, expand=true, padding=0.5, align=Align:Left) {
    
                ChatReplyText
            }
        } else {
            HStack(expand=true, padding=0.5, align=Align:Left) {
                ChatReplyText
            }
        }
    }

    give<replyText> ChatReplyText {
        P {
            let revealLength = 1
            with Tick(0.02s) {
                %(replyText.Substring(0, revealLength))
                if revealLength < replyText.Length {
                    revealLength += 1
                } else {
                    break
                }
            }
        }
    }
    once Pressed<changeReply> {
        delete give<replyText>
    }
    
    once Pressed<acceptReply> {
        SendChat(text=replyText)
        Expire
    }
    
    give ChatReplyButton {
        RaisedButton(PressIntent<acceptReply>, backgroundColor=Color:Primary) { "Send" }
    }
}